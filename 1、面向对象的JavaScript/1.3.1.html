<script type="text/javascript">
	/* 
			封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨
		论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。 （封装数据，封装实现，封装类型，封装变化）
			
		*/

	// 封装数据

	/* 
	
		JavaScript并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，
	而且只能模拟出 public 和 private 这两种封装性
	
	 */

	 /* 
	 	// 函数自执行；模拟封装 私有变量 

		// return Object ,提供 getter方法 

	  */
	var myObject = (function () {
		var __name = 'sven'; // 私有（private）变量
		return {
			getName: function () { // 公开（public）方法
				return __name;
			}
		}
	})();

	console.log(myObject.getName()); // 输出：sven
	console.log(myObject.__name) // 输出：undefined


	// 封装实现

	/* 
		从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。
	对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合
			变松散，对象之间只通过暴露的 API接口来通信。当我们修改一个对象时，可以随意地修改它的
	内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。
	
	 */
	

	// 封装类型
	// =>  JavaScript中，并没有对抽象类和接口的支持


	// 封装变化（设计模式的主题。）
	/* 
		从设计模式的角度出发，封装在更重要的层面体现为封装变化。  关键在于封装发生变化的概念，这是许多设计模式的主题。

	 */

	 /* 
	 
	 	23种设计模式分别被划分为创建型模式、结构型模式和行为型模式

		创建型模式的目的就是封装创建对象的变化。
		 
		而结构型模式封装的是对象之间的组合关系。
		 
		行为型模式封装的是对象的行为变化

	// => 
		通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变
	过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对
	容易。这可以最大程度地保证程序的稳定性和可扩展性
	  */
</script>